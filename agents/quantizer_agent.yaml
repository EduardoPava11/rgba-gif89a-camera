name: quantizer_agent
version: "1.0"
type: specialist
domain: alpha_aware_quantization

system_prompt: |
  You are an alpha-aware color quantization specialist focused on Oklab k-means and Floyd-Steinberg dithering.
  Your responsibilities:
  - Implement A-weighted k-means clustering in Oklab color space for palette generation
  - Apply Floyd-Steinberg dithering with alpha-scaled error diffusion strength
  - Manage palette evolution between frames with warm-start seeding
  - Generate indexed pixel data and feedback maps for temporal consistency
  - Optimize for mobile CPU performance with SIMD where possible
  
  Key technical constraints:
  - Input: RGB [81×81×3] + Alpha [81×81×1] from neural downsizer
  - Alpha weighting function: weight = alpha^0.7 per pixel
  - Target: 256-color palette per frame (global palette in later milestones)
  - Dithering: Floyd-Steinberg with strength = base_strength * alpha
  - Output: Indexed [81×81] + palette [256×3] + error/usage maps
  - Performance: <20ms per frame on Snapdragon 8 Gen 2

tools:
  - name: read_file
    paths:
      - "rust-core/src/quantizer.rs"
      - "rust-core/src/palette.rs"
      - "rust-core/src/dithering.rs"
      - "rust-core/src/pipeline.rs"
      - "rust-core/Cargo.toml"
  - name: edit_file
    paths:
      - "rust-core/src/quantizer.rs"
      - "rust-core/src/palette.rs"
      - "rust-core/src/dithering.rs"
      - "agents/quantizer_agent.yaml"
  - name: run_command
    commands:
      - "cargo test -p rust-core test_quantizer"
      - "cargo bench -p rust-core bench_quantization"
      - "cargo test -p rust-core test_oklab_conversion"
      - "cargo test -p rust-core test_alpha_weighting"
  - name: analyze_color_space
    description: "Visualize palette distribution in Oklab space"

responsibilities:
  primary:
    - "Implement AlphaAwareQuantizer with k-means++ seeding"
    - "RGB→Oklab conversion with proper gamut handling"
    - "A-weighted pixel sampling (weight = alpha^0.7)"
    - "Floyd-Steinberg with alpha-modulated error strength"
    - "Generate error maps and usage heatmaps for feedback"
  
  quality_gates:
    - "Quantization time <20ms per 81×81 frame"
    - "Palette utilization >80% (minimal unused colors)"
    - "Mean ΔE (Oklab) <3.0 for typical camera content"
    - "Temporal stability: <20% palette drift between frames"

mcp:
  version: 1
  references:
    - "https://docs.anthropic.com/en/docs/claude-code/sub-agents"
    - "https://bottosson.github.io/posts/oklab/"
  model: "claude-3.7-sonnet"
  context_size: 200000
  allow_chain_of_thought: true
  tool_limits:
    run_command:
      timeout_ms: 45000
      allow_network: false
    edit_file:
      max_edits_per_run: 8
    read_file:
      max_bytes: 262144
  env:
    RUST_LOG: "info"
    RAYON_NUM_THREADS: "4"

interfaces:
  input:
    - rgb_81x81: "[81,81,3] f32 (0.0-1.0)"
    - alpha_81x81: "[81,81,1] f32 (0.0-1.0)"
    - palette_prev: "Option<Vec<[f32; 3]>> (for warm-start)"
    - config: "QuantizerConfig"
  
  output:
    - indexed: "[81,81] u8 (palette indices)"
    - palette: "Vec<[u8; 3]> (≤256 RGB colors)"
    - error_map: "[81,81] f32 (quantization error)"
    - usage_map: "[81,81] f32 (palette usage heatmap)"

contracts:
  invariants:
    - "RGB input in [0,1]; Alpha input in [0,1]; no NaN/Inf values."
    - "Palette size ≤256 colors; indices in range [0, palette.len()-1]."
    - "Error map represents local ΔE values in Oklab space."
    - "Usage map tracks frequency of each palette color."
  preconditions:
    - "RGB and Alpha tensors have matching dimensions [81×81]."
    - "If palette_prev provided, must be valid RGB colors in [0,1]."
  postconditions:
    - "All pixels have valid palette indices; no out-of-bounds references."
    - "Mean ΔE <3.0 for representative camera content."
    - "Palette utilization >80% (unused colors <20%)."

code_templates:
  oklab_conversion: |
    fn rgb_to_oklab(rgb: [f32; 3]) -> [f32; 3] {
        // Linear RGB to OKLCh
        let l = 0.4122214708 * rgb[0] + 0.5363325363 * rgb[1] + 0.0514459929 * rgb[2];
        let m = 0.2119034982 * rgb[0] + 0.6806995451 * rgb[1] + 0.1073969566 * rgb[2];
        let s = 0.0883024619 * rgb[0] + 0.2817188376 * rgb[1] + 0.6299787005 * rgb[2];
        
        let l = l.cbrt();
        let m = m.cbrt();
        let s = s.cbrt();
        
        [
            0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s,
        ]
    }
  
  alpha_weighted_kmeans: |
    pub fn quantize_frame(
        &mut self,
        rgb: &[f32], 
        alpha: &[f32],
        output_size: u32
    ) -> Result<(Vec<u8>, Vec<[u8; 3]>, Vec<f32>, Vec<f32>)> {
        // Convert to Oklab and weight by alpha^0.7
        let samples: Vec<_> = rgb.chunks_exact(3)
            .zip(alpha.iter())
            .enumerate()
            .map(|(i, (rgb_pixel, &alpha_val))| {
                let oklab = rgb_to_oklab([rgb_pixel[0], rgb_pixel[1], rgb_pixel[2]]);
                let weight = alpha_val.powf(0.7);
                WeightedSample { oklab, weight, index: i }
            })
            .collect();
        
        // K-means with weighted centroids
        let palette = self.weighted_kmeans(&samples, 256)?;
        
        // Floyd-Steinberg with alpha-scaled error
        let (indexed, error_map) = self.apply_dithering(&samples, &palette)?;
        let usage_map = self.compute_usage_map(&indexed, palette.len());
        
        Ok((indexed, palette, error_map, usage_map))
    }

runbooks:
  palette_stability_check:
    steps:
      - "Run quantization on 10 consecutive frames with similar content."
      - "Measure palette drift: count colors that changed between frames."
      - "Assert <20% color change for stable camera scenes."
  color_accuracy_validation:
    steps:
      - "Generate synthetic test patterns in RGB."
      - "Quantize with various alpha weights (0.1, 0.5, 0.9)."
      - "Compute mean ΔE in Oklab space vs ground truth."
      - "Assert mean ΔE <3.0 for all alpha levels."

acceptance_tests:
  - test_name: "oklab_roundtrip"
    input: "Pure RGB colors (red, green, blue, white, black)"
    expected: "RGB→Oklab→RGB error <0.01"
  
  - test_name: "alpha_weighting"
    input: "High-alpha (1.0) vs low-alpha (0.1) pixels"
    assertion: "High-alpha pixels get higher weight in k-means"
  
  - test_name: "palette_size_limit"
    input: "Complex gradient image"
    expected: "Palette ≤256 colors always"
  
  - test_name: "dithering_quality"
    input: "Smooth gradient with varying alpha mask"
    assertion: "Lower alpha regions have reduced dithering artifacts"
  
  - test_name: "performance_target"
    device_profile: "snapdragon_8_gen_2"
    input: "81×81 RGB+A frame"
    assertion: "Quantization completes in <20ms"
  
  - test_name: "temporal_stability"
    input: "10 frames of static scene with noise"
    assertion: "Palette drift <20% between consecutive frames"

device_profiles:
  snapdragon_8_gen_2:
    cpu: "Kryo Prime 1×3.2GHz + Gold + Silver"
    ram_gb: 8
    os: "Android 14"
    notes: "Target quantization budget <20ms per 81×81 frame"
