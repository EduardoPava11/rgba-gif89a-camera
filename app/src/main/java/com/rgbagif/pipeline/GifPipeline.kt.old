package com.rgbagif.pipeline

import android.util.Log
import java.io.File

// These will be generated by UniFFI, but we'll create stubs for now
data class FrameInfo(
    val width: UInt,
    val height: UInt,
    val timestampMs: ULong
)

data class SessionConfig(
    val useGlobalPalette: Boolean = true,
    val allowPaletteGrowth: Boolean = true,
    val maxFrames: UInt = 81u,
    val outputSize: UInt = 81u
)

data class Feedback(
    val aPrev81x81: ByteArray,
    val errPrev81x81: ByteArray,
    val usagePrev81x81: ByteArray
)

data class PipelineStats(
    val framesProcessed: UInt,
    val paletteColors: UInt,
    val avgProcessingMs: Float,
    val avgQuantizationError: Float
)

/**
 * GIF Pipeline wrapper for Rust UniFFI interface
 * This will be replaced by the generated bindings
 */
class GifPipeline private constructor(
    private val handle: Long // Rust object handle
) {
    companion object {
        private const val TAG = "GifPipeline"
        
        init {
            try {
                System.loadLibrary("gifpipe")
                Log.d(TAG, "Loaded gifpipe native library")
            } catch (e: UnsatisfiedLinkError) {
                Log.e(TAG, "Failed to load gifpipe library", e)
            }
        }
        
        /**
         * Create a new GIF pipeline
         */
        fun create(
            outputDir: File,
            useGlobalPalette: Boolean = true,
            allowPaletteGrowth: Boolean = true
        ): GifPipeline {
            val config = SessionConfig(
                useGlobalPalette = useGlobalPalette,
                allowPaletteGrowth = allowPaletteGrowth,
                maxFrames = 81u,
                outputSize = 81u
            )
            
            // This will call the Rust constructor through UniFFI
            // For now, return a stub
            return GifPipeline(0L)
        }
    }
    
    /**
     * Push RGBA frame for processing
     */
    fun pushFrame(rgbaData: ByteArray, frameInfo: FrameInfo) {
        Log.d(TAG, "Processing frame: ${frameInfo.width}Ã—${frameInfo.height}")
        // Call Rust through UniFFI
        // nativePushFrame(handle, rgbaData, frameInfo)
    }
    
    /**
     * Finalize and save GIF
     */
    fun finalizeToPath(outputPath: String) {
        Log.d(TAG, "Finalizing GIF to: $outputPath")
        // Call Rust through UniFFI
        // nativeFinalizeToPath(handle, outputPath)
    }
    
    /**
     * Get latest feedback for debugging
     */
    fun getLatestFeedback(): Feedback? {
        // Call Rust through UniFFI
        return null
    }
    
    /**
     * Get pipeline statistics
     */
    fun getStats(): PipelineStats {
        // Call Rust through UniFFI
        return PipelineStats(0u, 0u, 0f, 0f)
    }
    
    // Native methods (will be generated by UniFFI)
    private external fun nativePushFrame(handle: Long, rgbaData: ByteArray, frameInfo: FrameInfo)
    private external fun nativeFinalizeToPath(handle: Long, outputPath: String)
    private external fun nativeGetLatestFeedback(handle: Long): Feedback?
    private external fun nativeGetStats(handle: Long): PipelineStats
    private external fun nativeDestroy(handle: Long)
    
    protected fun finalize() {
        // Clean up Rust resources
        // nativeDestroy(handle)
    }
}